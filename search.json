[
  {
    "objectID": "slosh.html#slosh",
    "href": "slosh.html#slosh",
    "title": "CSC 453",
    "section": "SLOsh",
    "text": "SLOsh\n\nThis assignment should be a refresher of 357 topics\nskeleton code on Canvas\nYour minimal shell will support:\n\nbasic command execution\nbuilt-in commands\nsignal handling\nI/O redirection\npiping"
  },
  {
    "objectID": "slosh.html#requirements",
    "href": "slosh.html#requirements",
    "title": "CSC 453",
    "section": "Requirements",
    "text": "Requirements\n\nC99 POSIX\nMust compile / run on the unix* servers\nYou must create a functional Makefile\nSubmit a tar (.tgz) file in Canvas"
  },
  {
    "objectID": "slosh.html#command-execution",
    "href": "slosh.html#command-execution",
    "title": "CSC 453",
    "section": "Command execution",
    "text": "Command execution\n\nExecute external commands\n\nUse fork(), exec(), and waitpid() to manage process execution\n\nSupport command-line arguments\nHandle both relative and absolute paths to executables\nReport command execution errors appropriately"
  },
  {
    "objectID": "slosh.html#redirection-piping",
    "href": "slosh.html#redirection-piping",
    "title": "CSC 453",
    "section": "Redirection / piping",
    "text": "Redirection / piping\n\nUse open(), dup2(), and close() for file redirection\nUse pipe() for creating pipes between processes"
  },
  {
    "objectID": "slosh.html#signal-handling",
    "href": "slosh.html#signal-handling",
    "title": "CSC 453",
    "section": "Signal handling",
    "text": "Signal handling\n\nSignals are async. They can happen at any time\nCertain functions are async-safe, others are not\n\nprintf() contains internal buffers and state; an interruption can lead to corrupted buffers"
  },
  {
    "objectID": "slosh.html#handling-sigint",
    "href": "slosh.html#handling-sigint",
    "title": "CSC 453",
    "section": "Handling SIGINT",
    "text": "Handling SIGINT\n\nwrite() a newline or whatever to signify the signal was caught.\nIf there is not a child running, write() a new prompt"
  },
  {
    "objectID": "slosh.html#parent-vs-child",
    "href": "slosh.html#parent-vs-child",
    "title": "CSC 453",
    "section": "Parent vs child",
    "text": "Parent vs child\n\nThe child should immediately reset signal handling to the default\nLook up signal()’s man\nman 2 signal"
  },
  {
    "objectID": "slosh.html#sigaction",
    "href": "slosh.html#sigaction",
    "title": "CSC 453",
    "section": "Sigaction",
    "text": "Sigaction\n\nsigaction() is newer than signal()\nOffers more control and is more consistent across systems\nAllows specifying flags\n\nSA_RESTART (man 7 signal)\n\nWithout it, syscalls return with EINTR error if they are interrupted by a signal\nWith it, most syscalls automatically restart\n\n\nIs the POSIX-compliant approach\nEINTR can still happen, it’s wise to check for it and handle it\n\nWhen reading input from user"
  },
  {
    "objectID": "slosh.html#section",
    "href": "slosh.html#section",
    "title": "CSC 453",
    "section": "",
    "text": "What isn’t clear?\nComments? Thoughts?"
  },
  {
    "objectID": "day4.html#admin",
    "href": "day4.html#admin",
    "title": "CSC 453",
    "section": "Admin",
    "text": "Admin\n\nQuiz 2 due Friday\nLab 2 due Monday\nSLOsh due Monday\nNo class/lab Tuesday"
  },
  {
    "objectID": "day4.html#questions-to-consider",
    "href": "day4.html#questions-to-consider",
    "title": "CSC 453",
    "section": "Questions to consider",
    "text": "Questions to consider\n\nWhich system calls are related to process management and lifecycles?\nHow does the process hierarchy work?\nWhat are zombies and orphans? Why do zombies exist?"
  },
  {
    "objectID": "day4.html#unix-process-apis",
    "href": "day4.html#unix-process-apis",
    "title": "CSC 453",
    "section": "UNIX process APIs",
    "text": "UNIX process APIs\n\nfork() creates a new child process\n\nAll processes are created by forking from a parent\nThe init process is ancestor of all processes\n\nRun pstree in a terminal to see\n\n\nexec() makes a process execute a given executable (effectively replaces the process)\nexit() terminates a process\nwait() causes a parent to block until child terminates\nMany variants exist of the above system calls with different arguments"
  },
  {
    "objectID": "day4.html#what-happens-during-a-fork",
    "href": "day4.html#what-happens-during-a-fork",
    "title": "CSC 453",
    "section": "What happens during a fork()?",
    "text": "What happens during a fork()?\n\nA new process is created by making a copy of parent’s memory image\nBoth parent and child have unique address spaces (isolated from each other, allowing for independent processing)\nThe new process is added to the OS process list and scheduled\nParent and child start execution just after fork (with different return values)\nParent and child execute and modify the memory data independently"
  },
  {
    "objectID": "day4.html#process-management-1",
    "href": "day4.html#process-management-1",
    "title": "CSC 453",
    "section": "Process management",
    "text": "Process management"
  },
  {
    "objectID": "day4.html#process-creation",
    "href": "day4.html#process-creation",
    "title": "CSC 453",
    "section": "Process creation",
    "text": "Process creation\n\nDifferent execution models\n\nParent & child may execute independently\nParent may wait for child\nChild may create more children (Process hierarchies)\nParent may kill children\n\nChild often invokes exec() to change its memory image to a new program\nWhy two steps (fork() then exec())?\n\nAllows the child to change file descriptors and other settings before exec()"
  },
  {
    "objectID": "day4.html#process-destruction",
    "href": "day4.html#process-destruction",
    "title": "CSC 453",
    "section": "Process destruction",
    "text": "Process destruction\n\nSome operating systems do not allow child to exist if its parent has terminated. If a process terminates, then all its children must also be terminated\n\nCascading termination: All children, grandchildren, etc., are terminated.\nThe termination is initiated by the operating system\n\nThe parent process may wait for termination of a child process by using the wait() system call. The call returns status information and the pid of the terminated process\npid = wait(&status);"
  },
  {
    "objectID": "day4.html#zombies-and-orphans",
    "href": "day4.html#zombies-and-orphans",
    "title": "CSC 453",
    "section": "Zombies and orphans",
    "text": "Zombies and orphans\n\n\n\nIf no parent waiting (did not invoke wait()), and process completes, process is a zombie\n\nZombie = dead but not yet reaped (exit status hasn’t been read)\nStill has an entry in the process table\nWe need zombies: so the kernel can preserve a child’s exit status until the parent calls wait(), even if the child exits first\n\nIf parent terminated without invoking wait(), process is an orphan\n\nOrphan = alive but parent is gone\ninit benevolently adopts orphans\n\n\n\n\n\n\n\n\nChild exits → zombie\nParent exits → zombie becomes orphan\ninit adopts it → init calls wait() → zombie disappears"
  },
  {
    "objectID": "day4.html#section",
    "href": "day4.html#section",
    "title": "CSC 453",
    "section": "",
    "text": "What isn’t clear?\nComments? Thoughts?"
  },
  {
    "objectID": "day4.html#questions-to-consider-1",
    "href": "day4.html#questions-to-consider-1",
    "title": "CSC 453",
    "section": "Questions to consider",
    "text": "Questions to consider\n\nWhat are namespaces and cgroups?\nHow do they differ from virtual machines?\nHow do containers use them to isolate processes?"
  },
  {
    "objectID": "day4.html#isolation-without-full-virtualization",
    "href": "day4.html#isolation-without-full-virtualization",
    "title": "CSC 453",
    "section": "Isolation without full virtualization",
    "text": "Isolation without full virtualization\n\nVirtual machines provide complete isolation by emulating entire hardware + OS\n\nHeavier resource overhead (multiple OS instances)\nBetter isolation between workloads\n\nContainers provide lightweight isolation using OS-level mechanisms\n\nShare the same kernel\nMuch lower overhead than VMs\nLinux kernel provides the building blocks: namespaces and cgroups"
  },
  {
    "objectID": "day4.html#namespaces-logical-isolation",
    "href": "day4.html#namespaces-logical-isolation",
    "title": "CSC 453",
    "section": "Namespaces: logical isolation",
    "text": "Namespaces: logical isolation\n\nNamespaces partition global system resources so they appear as separate isolated instances\nEach process belongs to a namespace and only sees resources in that namespace\nTypes of namespaces:\n\nPID: process IDs (what processes can a process see?)\nNetwork: network interfaces, ports, routing tables\nMount: filesystem mounts (what can a process access?)\nIPC: IPC objects, message queues\nUTS: hostname and domain name\nUser: user and group IDs (who owns the process?)"
  },
  {
    "objectID": "day4.html#namespaces-example",
    "href": "day4.html#namespaces-example",
    "title": "CSC 453",
    "section": "Namespaces example",
    "text": "Namespaces example\n\nTwo processes in separate PID namespaces think they are PID 1 (init)\nEach sees only processes within their own namespace\nFrom the host OS perspective, they have different global PIDs\nEnables the illusion that each container has its own isolated process tree"
  },
  {
    "objectID": "day4.html#seeing-namespaces-in-action",
    "href": "day4.html#seeing-namespaces-in-action",
    "title": "CSC 453",
    "section": "Seeing namespaces in action",
    "text": "Seeing namespaces in action\n\nView namespaces a process belongs to:\nls -l /proc/self/ns/\nUse unshare to create a new PID namespace:\nunshare -pf --mount-proc bash      # creates new PID namespace, your shell is PID 1\nps aux               # only sees processes in this namespace\nexit                 # back to host namespace\nps aux               # will show all processes on the host\nCompare namespace inodes before and after (same inode = same namespace):\nls -i /proc/self/ns/pid\nunshare -pf --mount-proc bash -c 'ls -i /proc/self/ns/pid'  # different inode"
  },
  {
    "objectID": "day4.html#cgroups-resource-limits",
    "href": "day4.html#cgroups-resource-limits",
    "title": "CSC 453",
    "section": "Cgroups: resource limits",
    "text": "Cgroups: resource limits\n\ncgroups (control groups) limit, prioritize, and account for resource usage of process groups\nKey capabilities:\n\nCPU limits: restrict how much CPU time a group can use\nMemory limits: cap memory usage; OOM killer invoked if exceeded\nI/O limits: restrict disk I/O bandwidth\nDevice access: restrict which devices a process can access\n\nAll processes in a cgroup share the same resource limitations"
  },
  {
    "objectID": "day4.html#seeing-cgroups-in-action",
    "href": "day4.html#seeing-cgroups-in-action",
    "title": "CSC 453",
    "section": "Seeing cgroups in action",
    "text": "Seeing cgroups in action\n\nView what cgroup a process belongs to:\ncat /proc/self/cgroup\nCheck your current limits:\ncat /proc/self/limits  # shows per-process limits (some enforced by cgroups)\nIn practice, cgroups are invisible to users, kernel enforces limits automatically when a process exceeds allocated resources"
  },
  {
    "objectID": "day4.html#cgroups-vs.-namespaces",
    "href": "day4.html#cgroups-vs.-namespaces",
    "title": "CSC 453",
    "section": "Cgroups vs. namespaces",
    "text": "Cgroups vs. namespaces\n\nNamespaces: about visibility—what can a process see?\n\nLogical isolation of resources\n\ncgroups: about limits—how much can a process use?\n\nResource accounting and enforcement\n\nTogether: processes appear isolated AND are prevented from consuming excessive resources"
  },
  {
    "objectID": "day4.html#containers-as-a-building-block",
    "href": "day4.html#containers-as-a-building-block",
    "title": "CSC 453",
    "section": "Containers as a building block",
    "text": "Containers as a building block\n\ncgroups and namespaces are mechanisms, containers allow us to apply policy through orchestration\nContainers (e.g. Docker) combine namespaces + cgroups + layered filesystems\nResults in lightweight, portable process isolation\nSingle kernel, multiple isolated environments\nMuch cheaper than VMs, but with less isolation guarantees"
  },
  {
    "objectID": "day4.html#section-1",
    "href": "day4.html#section-1",
    "title": "CSC 453",
    "section": "",
    "text": "What isn’t clear?\nComments? Thoughts?"
  },
  {
    "objectID": "day4.html#questions-to-consider-2",
    "href": "day4.html#questions-to-consider-2",
    "title": "CSC 453",
    "section": "Questions to consider",
    "text": "Questions to consider\n\nWhat are the two main strategies for IPC?\nHow do they differ?\nIn what situations would you choose one over the other?"
  },
  {
    "objectID": "day4.html#processes-give-us-a-protection-boundary",
    "href": "day4.html#processes-give-us-a-protection-boundary",
    "title": "CSC 453",
    "section": "Processes give us a protection boundary",
    "text": "Processes give us a protection boundary\n\nThe operating system is responsible for isolating processes from each other\nWhat you do in your own process is your own business but it shouldn’t be able to crash the machine or affect other processes, or at least processes started by other users\nThus: safe intra-process communication is your problem; safe inter-process communication is an operating system problem"
  },
  {
    "objectID": "day4.html#why-do-we-need-ipc-what-are-the-benefits",
    "href": "day4.html#why-do-we-need-ipc-what-are-the-benefits",
    "title": "CSC 453",
    "section": "Why do we need IPC? What are the benefits?",
    "text": "Why do we need IPC? What are the benefits?\n\nData Sharing: IPC allows processes to share data efficiently, which is crucial for applications requiring real-time data exchange\nModularity: It promotes modularity by enabling different parts of a system to communicate, making the system easier to manage and scale\nResource Utilization: IPC can help optimize resource utilization by allowing processes to coordinate their use of shared resources\nConcurrency (scalability): It supports concurrent execution of processes, improving the overall performance and responsiveness of applications"
  },
  {
    "objectID": "day4.html#what-are-the-disadvantages-of-ipc",
    "href": "day4.html#what-are-the-disadvantages-of-ipc",
    "title": "CSC 453",
    "section": "What are the disadvantages of IPC?",
    "text": "What are the disadvantages of IPC?\n\nComplexity: Implementing IPC can add complexity to the system, requiring careful design and management to avoid issues like deadlocks and race conditions\nOverhead: IPC mechanisms can introduce overhead, potentially impacting performance, especially if the communication is frequent or involves large amounts of data\nSecurity: Ensuring secure IPC can be challenging, as it involves protecting data from unauthorized access and ensuring the integrity of the communication\nDebugging: Debugging IPC-related issues can be difficult, as problems may arise from interactions between multiple processes, making them harder to isolate and resolve"
  },
  {
    "objectID": "day4.html#what-are-the-two-main-categories-of-ipc",
    "href": "day4.html#what-are-the-two-main-categories-of-ipc",
    "title": "CSC 453",
    "section": "What are the two main categories of IPC?",
    "text": "What are the two main categories of IPC?\n\nMessage passing\n\nHigh-level abstraction for exchanging packets of information over some interconnect\n\nShared memory\n\nRegion of memory available to different processes; writable by at least one process"
  },
  {
    "objectID": "day4.html#message-passing",
    "href": "day4.html#message-passing",
    "title": "CSC 453",
    "section": "Message passing",
    "text": "Message passing\n\nKernel establishes and oversees all communication\n\nProcess copies data to buffer, then issue system call to request transfer\nKernel copies data into its memory\nLater, process issues system call to retrieve\n\nTwo primitives: send() and recv()\nBeyond intra-computer communication, facilitates processes over a network; link implementation is unimportant"
  },
  {
    "objectID": "day4.html#pros-and-cons-of-message-passing",
    "href": "day4.html#pros-and-cons-of-message-passing",
    "title": "CSC 453",
    "section": "Pros and cons of message passing?",
    "text": "Pros and cons of message passing?\n\nPros:\n\nEasier to implement and manage, especially in distributed systems\nProvides clear boundaries between processes, enhancing security and modularity\n\nCons:\n\nCan introduce overhead due to the need for message formatting and transmission\nMay be slower compared to shared memory for large volumes of data"
  },
  {
    "objectID": "day4.html#shared-memory",
    "href": "day4.html#shared-memory",
    "title": "CSC 453",
    "section": "Shared memory",
    "text": "Shared memory\n\nKernel plays a role in establishing and attaching the address space, but does not control read/write access beyond that\nHow the memory is shared, and kept consistent, is left up to the processes"
  },
  {
    "objectID": "day4.html#pros-and-cons-of-shared-memory",
    "href": "day4.html#pros-and-cons-of-shared-memory",
    "title": "CSC 453",
    "section": "Pros and cons of shared memory?",
    "text": "Pros and cons of shared memory?\n\nPros:\n\nOffers high-speed data exchange, as processes can directly read and write to the shared memory\nEfficient for large volumes of data\n\nCons:\n\nRequires careful synchronization to avoid conflicts and ensure data consistency\nCan be more complex to implement and debug"
  },
  {
    "objectID": "day4.html#message-passing-vs.-shared-memory",
    "href": "day4.html#message-passing-vs.-shared-memory",
    "title": "CSC 453",
    "section": "Message passing vs. shared memory",
    "text": "Message passing vs. shared memory\n\n\n\nWhich do you choose?\n\nIf you have few messages?\nIf you have millions?\nIf you need to communicate across systems?\nIf you need in-order delivery but don’t want to code it yourself?\n\nConsiderations:\n\nCost to establish\nCost per message\n\n\n\n\n\n “Gemini, make an image in the style of a video game pitting pipes versus shared memory”"
  },
  {
    "objectID": "day4.html#section-2",
    "href": "day4.html#section-2",
    "title": "CSC 453",
    "section": "",
    "text": "What isn’t clear?\nComments? Thoughts?"
  },
  {
    "objectID": "day3.html#admin",
    "href": "day3.html#admin",
    "title": "CSC 453",
    "section": "Admin",
    "text": "Admin\n\nLab 1 due tonight\n\nWindows users: there are some settings to make the VM work if you missed lab\n\nProgramming assignment 1 due next Monday"
  },
  {
    "objectID": "day3.html#questions-to-consider",
    "href": "day3.html#questions-to-consider",
    "title": "CSC 453",
    "section": "Questions to consider",
    "text": "Questions to consider\n\nHow do we ensure that a user process doesn’t harm others?\nHow do system calls work? How do they related to wrapper libraries like glibc?"
  },
  {
    "objectID": "day3.html#dual-mode-operation",
    "href": "day3.html#dual-mode-operation",
    "title": "CSC 453",
    "section": "Dual-mode operation",
    "text": "Dual-mode operation\n\nDual-mode operation allows OS to protect itself and components\n\nUser mode and kernel mode\n\nMode bit provided by hardware\n\nProvides ability to distinguish when system is running user code or kernel code.\nWhen a user is running → mode bit is “user”\nWhen kernel code is executing → mode bit is “kernel”\n\nSystem call changes mode to kernel, return from call resets it to user\nSome instructions are only executable in kernel mode"
  },
  {
    "objectID": "day3.html#system-calls",
    "href": "day3.html#system-calls",
    "title": "CSC 453",
    "section": "System calls",
    "text": "System calls\n\nThe OS offers a number of services. How do we (applications) interface with them?\n\nWe don’t want to deal with the details, just the abstraction\nThe OS has ultimate control over these operations\n\nSystem calls are the “language” of communication with the OS\nStandards\n\nWin32 (MS)\nPOSIX (nearly all Unix-based systems)\nJava API for the JVM"
  },
  {
    "objectID": "day3.html#system-calls-contd",
    "href": "day3.html#system-calls-contd",
    "title": "CSC 453",
    "section": "System calls (cont’d)",
    "text": "System calls (cont’d)\n\nLike a function call, we push arguments onto the stack, then we call into the library that provides the system call\nEach system call has a special number, placed into a register\nExecutes a TRAP instruction (switch to kernel mode)\nA logical separation of memory space\nKernel’s system call handler is invoked, once done (but may block) may be returned to the process"
  },
  {
    "objectID": "day3.html#system-calls-contd-1",
    "href": "day3.html#system-calls-contd-1",
    "title": "CSC 453",
    "section": "System calls (cont’d)",
    "text": "System calls (cont’d)\n\nTable defined in the kernel: https://github.com/torvalds/linux/blob/master/arch/x86/entry/ syscalls/syscall_32.tbl\n\nNote that system call tables can differ between architectures\n\nYou can run using the table values themselves using the syscall() wrapper\n\nQ: why does syscall() exist?\nIf you’re interested… There are debates https://lwn.net/Articles/771441/"
  },
  {
    "objectID": "day3.html#section",
    "href": "day3.html#section",
    "title": "CSC 453",
    "section": "",
    "text": "What isn’t clear?\nComments? Thoughts?"
  },
  {
    "objectID": "day3.html#questions-to-consider-1",
    "href": "day3.html#questions-to-consider-1",
    "title": "CSC 453",
    "section": "Questions to consider",
    "text": "Questions to consider\n\nWhat do processes contain?\nHow does the OS run multiple processes at the same time?\nHow are processes laid out in memory?\nHow does the OS store information about each process?"
  },
  {
    "objectID": "day3.html#processes",
    "href": "day3.html#processes",
    "title": "CSC 453",
    "section": "Processes",
    "text": "Processes\n\nMost fundamental OS abstraction\n\nProcesses organize information about other abstractions and represent a single thing the computer is “doing”\n\nWhen you run an executable program (passive), the OS creates a process == a running program (active)\nOne program can be multiple processes"
  },
  {
    "objectID": "day3.html#process-organization",
    "href": "day3.html#process-organization",
    "title": "CSC 453",
    "section": "Process organization",
    "text": "Process organization\n\n\n\nUnlike threads, address spaces and files, processes are not tied to a hardware component. Instead, they contain other abstractions\nProcesses contain:\n\none or more threads,\nan address space, and\nzero or more open file handles representing files"
  },
  {
    "objectID": "day3.html#multiprogramming",
    "href": "day3.html#multiprogramming",
    "title": "CSC 453",
    "section": "Multiprogramming",
    "text": "Multiprogramming\n\nProcesses are the core abstraction that allows for multiprogramming: the illusion of concurrency\nOS timeshares CPU across multiple processes: virtualizes CPU\nOS has a CPU scheduler that picks one of the many active processes to execute on a CPU\nPolicy:\n\nwhich process to run\n\nMechanism:\n\nhow to context switch between processes"
  },
  {
    "objectID": "day3.html#processs-view-of-the-world",
    "href": "day3.html#processs-view-of-the-world",
    "title": "CSC 453",
    "section": "Process’s view of the world",
    "text": "Process’s view of the world\n\n\n\nOwn memory with consistent addressing (divorced from physical addressing)\nIt has exclusivity over the CPU: It doesn’t have to worry about scheduling\nConversely, it doesn’t know when it will be scheduled, so real time events require special handling\nHas some identity: pid, gid, uid\nHas a set of services available to it via the OS\n\nData (via file system)\nCommunication (sockets, IPC)\nMore resources (e.g., memory)"
  },
  {
    "objectID": "day3.html#process-memory-layout",
    "href": "day3.html#process-memory-layout",
    "title": "CSC 453",
    "section": "Process memory layout",
    "text": "Process memory layout\n\n\n\nText segment: machine instructions; shareable between identical processes; read-only\nData segment: for initialized data; e.g., int count = 99;\nBSS (block started by symbol) segment: uninitialized data; e.g., int sum[10];\nHeap: dynamic memory allocation\nStack: initial arguments and environment; stack frames"
  },
  {
    "objectID": "day3.html#oss-view-of-the-process-world",
    "href": "day3.html#oss-view-of-the-process-world",
    "title": "CSC 453",
    "section": "OS’s view of the (process) world",
    "text": "OS’s view of the (process) world\n\n\n\nData for each process is held in a data structure known as a Process Control Block\nPartitioned memory:\n\ndedicated & shared address space\n\nperhaps non-contiguous\n\nProcess table holds PCBs"
  },
  {
    "objectID": "day3.html#section-1",
    "href": "day3.html#section-1",
    "title": "CSC 453",
    "section": "",
    "text": "What isn’t clear?\nComments? Thoughts?"
  },
  {
    "objectID": "day3.html#questions-to-consider-2",
    "href": "day3.html#questions-to-consider-2",
    "title": "CSC 453",
    "section": "Questions to consider",
    "text": "Questions to consider\n\nWhat are the different process states and what causes transitions?\nWhat is a context switch?\nWhat are the two general categories of processes and how do they differ?"
  },
  {
    "objectID": "day3.html#process-states",
    "href": "day3.html#process-states",
    "title": "CSC 453",
    "section": "Process states",
    "text": "Process states\n\nAs a process executes, it changes state\n\nNew: The process is being created\nRunning: Instructions are being executed\nWaiting: The process is waiting for some event (typically I/O or signal handling) to occur\nReady: The process is waiting to be assigned to a processor\nTerminated: The process has finished execution"
  },
  {
    "objectID": "day3.html#process-state-transitions",
    "href": "day3.html#process-state-transitions",
    "title": "CSC 453",
    "section": "Process state transitions",
    "text": "Process state transitions"
  },
  {
    "objectID": "day3.html#process-state-transitions-contd",
    "href": "day3.html#process-state-transitions-contd",
    "title": "CSC 453",
    "section": "Process state transitions (cont’d)",
    "text": "Process state transitions (cont’d)\n\n\n\nRunning process can move from running to terminated (exit or killed), moved to ready (time slice up), or blocked (signaled to wait, I/O)\nWhich state transitions could happen with these expensive actions?\n\nCompute a new RSA key?\nFind the largest value in a 1TB of data?\n\n\n\n\n\n\n\n\n\nRunning to Waiting: This transition occurs when a process cannot continue executing until a specific event occurs. Here are some examples:\n\nI/O Operations:\n\nExample: A process needs to read data from a disk. It issues an I/O request and then moves to the Waiting state until the data is read and available.\nReal-World Scenario: A web server process waiting for data to be read from a database.\n\nResource Availability:\n\nExample: A process requires a resource (like a printer) that is currently in use by another process. It moves to the Waiting state until the resource becomes available.\nReal-World Scenario: A document editing application waiting for access to a shared printer.\n\nInter-Process Communication (IPC):\n\nExample: A process is waiting for a message from another process. It moves to the Waiting state until the message is received.\nReal-World Scenario: A chat application waiting for a message from a server.\n\nSynchronization Primitives:\n\nExample: A process is waiting for a lock or semaphore to be released by another process. It moves to the Waiting state until the lock is available.\nReal-World Scenario: A banking application waiting for a transaction lock to be released.\n\n\nRunning to Ready: This transition occurs when a process is preempted by the scheduler, but it is still ready to run as soon as it gets CPU time again. Here are some examples:\n\nTime Slice Expiration:\n\nExample: A process has used up its allocated time slice. The scheduler preempts it and moves it to the Ready state, allowing another process to run.\nReal-World Scenario: A video streaming application being preempted to allow a background update process to run.\n\nHigher Priority Process:\n\nExample: A higher priority process becomes ready to run. The scheduler preempts the current process and moves it to the Ready state.\nReal-World Scenario: An emergency alert system preempting a running media player application.\n\nVoluntary Yield:\n\nExample: A process voluntarily yields the CPU, indicating it can be preempted. The scheduler moves it to the Ready state.\nReal-World Scenario: A background data synchronization process yielding the CPU to allow a user-initiated task to run."
  },
  {
    "objectID": "day3.html#process-scheduling",
    "href": "day3.html#process-scheduling",
    "title": "CSC 453",
    "section": "Process scheduling",
    "text": "Process scheduling\n\nOS process scheduler selects among available processes for next execution on CPU core\nGoal?\n\nMaximize CPU use, quickly switch processes onto CPU core\n\nMaintains scheduling queues of processes\n\nReady queue: set of all processes residing in main memory, ready and waiting to execute\nWait queues: set of processes waiting for an event (i.e., I/O)\n\nProcesses migrate among the various queues over their lifetime"
  },
  {
    "objectID": "day3.html#context-switching",
    "href": "day3.html#context-switching",
    "title": "CSC 453",
    "section": "Context switching",
    "text": "Context switching\n\nWhen CPU switches to another process, the system must save the state of the old process and load the saved state for the new process via a context switch\nContext of a process represented in the PCB\nContext-switch time is pure overhead; the system does no useful work while switching\n\nThe more complex the OS and the PCB → the longer the context switch\n\nTime dependent on hardware support\n\nSome hardware provides multiple sets of registers per CPU → multiple contexts loaded at once"
  },
  {
    "objectID": "day3.html#context-switching-overhead",
    "href": "day3.html#context-switching-overhead",
    "title": "CSC 453",
    "section": "Context switching overhead",
    "text": "Context switching overhead\n\nOn the order of milliseconds\nIf not done intelligently, you can spend more time context-switching than actual processing\nQuestion: Why shouldn’t processes control context switching?\n\n\n\nThey could refuse to give up CPU (processes are greedy)\nThey’re intentionally isolated, and don’t have enough information about other processes\nIt would cause too much complication (every process would have to implement its own context switch code)"
  },
  {
    "objectID": "day3.html#scheduling-basics",
    "href": "day3.html#scheduling-basics",
    "title": "CSC 453",
    "section": "Scheduling basics",
    "text": "Scheduling basics\n\nScheduler usually makes the transition decisions; hides the details from the process/user\nProcesses often characterized as one of two types by what state they spend most of their time in\n\nI/O bound: work is dependent on I/O; e.g., browser, db, media streaming\nCPU bound: work is dependent on CPU; e.g., scientific apps, cryptography\nWhy does this matter?\n\nUnderstanding which your process is allows for optimization\n\nCPU-bound? Faster CPU, parallelize.\nI/O? Faster I/O devices, use async\n\n\n\nScheduler must balance CPU- & I/O-bound processes\n\nReminder: the goal is to maximize CPU utilization"
  },
  {
    "objectID": "day3.html#aside-multiprocessing-in-mobile",
    "href": "day3.html#aside-multiprocessing-in-mobile",
    "title": "CSC 453",
    "section": "Aside: multiprocessing in mobile",
    "text": "Aside: multiprocessing in mobile\n\nSome mobile systems (e.g., early versions of iOS) allow only one process to run, others suspended\nDue to screen real estate, user interface limits iOS provides:\n\nSingle foreground process controlled via user interface\nMultiple background processes in memory, running, but not on the display, and with limits\n\nLimits include single, short task, receiving notification of events, specific long-running tasks like audio playback\n\n\nAndroid runs foreground and background, with fewer limits\n\nBackground process uses a service to perform tasks\nService can keep running even if background process is suspended\nService has no user interface, small memory use"
  },
  {
    "objectID": "day3.html#section-2",
    "href": "day3.html#section-2",
    "title": "CSC 453",
    "section": "",
    "text": "What isn’t clear?\nComments? Thoughts?"
  },
  {
    "objectID": "day2.html#admin",
    "href": "day2.html#admin",
    "title": "CSC 453",
    "section": "Admin",
    "text": "Admin\n\nQuiz 1 due Friday\n\nNOTE: this first quiz allows unlimited attempts. The rest will not.\n\nLab 1 due Monday\nAssignment 1 due Jan 19\n\nI’ll talk a bit about this during lab today\n\nI realize this seem like a lot, but time is short"
  },
  {
    "objectID": "day2.html#questions-to-consider",
    "href": "day2.html#questions-to-consider",
    "title": "CSC 453",
    "section": "Questions to consider",
    "text": "Questions to consider\n\nWhat are the main abstractions OSes provide?\nWhat are the abstraction challenges?"
  },
  {
    "objectID": "day2.html#abstractions",
    "href": "day2.html#abstractions",
    "title": "CSC 453",
    "section": "Abstractions",
    "text": "Abstractions\n\nAbstractions simplify application design by:\n\nhiding undesirable properties,\nadding new capabilities, and\norganizing information\n\nAbstractions provide an interface to application programmers that separates policy—what the interface commits to accomplishing—from mechanism—how the interface is implemented."
  },
  {
    "objectID": "day2.html#what-are-the-abstractions",
    "href": "day2.html#what-are-the-abstractions",
    "title": "CSC 453",
    "section": "What are the abstractions?",
    "text": "What are the abstractions?\n\nCPUs\n\nProcesses, threads\n\nMemory\n\nAddress space\n\nDisk\n\nFiles"
  },
  {
    "objectID": "day2.html#example-os-abstraction-file-systems",
    "href": "day2.html#example-os-abstraction-file-systems",
    "title": "CSC 453",
    "section": "Example OS abstraction: file systems",
    "text": "Example OS abstraction: file systems\n\nWhat undesirable properties do file systems hide?\n\nDisks are slow!\nChunks of storage are actually distributed all over the disk\nDisk storage may fail!\n\nWhat new capabilities do files add?\n\nGrowth and shrinking\nOrganization into directories, searchability\n\nWhat information do files help organize?\n\nOwnership and permissions\nAccess time, modification time, type, etc."
  },
  {
    "objectID": "day2.html#abstraction-tradeoffs---discussion",
    "href": "day2.html#abstraction-tradeoffs---discussion",
    "title": "CSC 453",
    "section": "Abstraction tradeoffs - discussion",
    "text": "Abstraction tradeoffs - discussion\n\nIdentify undesirable properties hidden by, new capabilities added, and info organization provided with these abstractions:\n\nProcess / threads\nAddress space\n\n\n\nProcesses/Threads\n\nHiding undesirable properties:\n\nExample: The process abstraction hides the complexity of CPU scheduling and context switching. Applications don’t need to manage the low-level details of how the CPU switches between different tasks. Similarly, the thread abstraction hides the intricacies of managing multiple execution paths within a single process, allowing developers to focus on the logic of concurrent tasks.\n\nAdding new capabilities:\n\nExample: Processes provide isolation between different applications, ensuring that one misbehaving application doesn’t affect others. Threads within a process allow for parallel execution of tasks, improving performance and responsiveness. Additionally, operating systems often provide inter-process communication (IPC) mechanisms, enabling processes to coordinate and share data.\n\nOrganizing information:\n\nExample: The process abstraction organizes the execution environment by encapsulating the code, data, and resources needed for a program to run. Threads further organize execution by dividing tasks within a process into smaller, manageable units. This organization helps in structuring complex applications and improving their maintainability.\n\n\nMemory Address Space\n\nHiding undesirable properties:\n\nExample: The memory address space abstraction hides the physical memory layout from applications. Programs use virtual addresses, which the operating system maps to physical memory locations. This abstraction also hides the details of memory fragmentation and allocation, simplifying memory management for developers.\n\nAdding new capabilities:\n\nExample: Virtual memory allows applications to use more memory than physically available by swapping data to and from disk. This capability enables larger and more complex applications to run on systems with limited physical memory. Additionally, memory protection mechanisms prevent one process from accessing the memory of another, enhancing system stability and security.\n\nOrganizing information:\n\nExample: The memory address space abstraction organizes memory into segments such as code, data, heap, and stack. This organization helps in managing different types of data efficiently and ensures that memory is used in a structured manner. For instance, the stack is used for function calls and local variables, while the heap is used for dynamic memory allocation."
  },
  {
    "objectID": "day2.html#abstraction-pros-cons",
    "href": "day2.html#abstraction-pros-cons",
    "title": "CSC 453",
    "section": "Abstraction pros / cons",
    "text": "Abstraction pros / cons\n\nAdvantages of OS providing abstractions?\n\nAllow applications to reuse common facilities\nMake different devices look the same\nProvide higher-level or more useful functionality\n\nChallenges?\n\nWhat are the correct abstractions?\nHow much should be exposed?"
  },
  {
    "objectID": "day2.html#os-design-requirements---what-do-we-need",
    "href": "day2.html#os-design-requirements---what-do-we-need",
    "title": "CSC 453",
    "section": "OS design requirements - what do we need?",
    "text": "OS design requirements - what do we need?\n\nConvenience, abstraction of hardware resources for user programs\nEfficiency of usage of CPU, memory, etc.\nIsolation between multiple processes\nReliability, the OS must not fail\nOther:\n\nSecurity\nMobility"
  },
  {
    "objectID": "day2.html#section",
    "href": "day2.html#section",
    "title": "CSC 453",
    "section": "",
    "text": "What isn’t clear?\nComments? Thoughts?"
  },
  {
    "objectID": "day2.html#questions-to-consider-1",
    "href": "day2.html#questions-to-consider-1",
    "title": "CSC 453",
    "section": "Questions to consider",
    "text": "Questions to consider\n\nHow does the OS manage access to resources?"
  },
  {
    "objectID": "day2.html#os-as-a-resource-manager",
    "href": "day2.html#os-as-a-resource-manager",
    "title": "CSC 453",
    "section": "OS as a resource manager",
    "text": "OS as a resource manager\n\nAnother view: resource manager - shares resources “well”\nAdvantages of the OS managing resources?\n\nProtect applications from one another\nProvide efficient access to resources (cost, time, energy)\nProvide fair access to resources\n\nChallenges?\n\nWhat are the correct mechanisms?\nWhat are the correct policies?"
  },
  {
    "objectID": "day2.html#resources-are-managed-via-services",
    "href": "day2.html#resources-are-managed-via-services",
    "title": "CSC 453",
    "section": "Resources are managed via services",
    "text": "Resources are managed via services\n\nProgram Execution (loading, running, monitoring, terminating)\nPerformance (optimizing resources under constraints)\nCorrectness (overseeing critical operations, preventing interference)\nFairness (access to and allocation of resources)\nError detection & recovery (network partition & media failure)"
  },
  {
    "objectID": "day2.html#services-contd",
    "href": "day2.html#services-contd",
    "title": "CSC 453",
    "section": "Services (cont’d)",
    "text": "Services (cont’d)\n\nCommunication (inter-process, software-to-hardware, hardware-to-hardware, system-to-system, wide-area)\nI/O: reading & writing, support for various mediums, devices, performance, and protections\nData Organization (naming), Services (search) & Protection (access control)\nSecurity (isolation, enforcement, services, authentication, accounting and logging, trust)\nUser interfaces (command-line, GUIs, multiple users)"
  },
  {
    "objectID": "day2.html#each-service-has-challenges-and-tensions",
    "href": "day2.html#each-service-has-challenges-and-tensions",
    "title": "CSC 453",
    "section": "Each service has challenges and tensions",
    "text": "Each service has challenges and tensions\nExample 1: We have limited RAM, and we want to run more programs that can be stored.\n\nHow do we allocate space?\nWho stays?\nWho goes?\nWhat if we’re wrong?\nWhat if the system is under extremely heavy load?\nIs there a way to predict the future?"
  },
  {
    "objectID": "day2.html#each-service-has-challenges-and-tensions-1",
    "href": "day2.html#each-service-has-challenges-and-tensions-1",
    "title": "CSC 453",
    "section": "Each service has challenges and tensions",
    "text": "Each service has challenges and tensions\nExample 2: We have two process (producer / consumer); how do they communicate?\n\nMessage passing? Shared memory?\nHow do they synchronize?\n\nHow to we prevent over-production? Over-consumption?\nContext-switching?"
  },
  {
    "objectID": "day2.html#section-1",
    "href": "day2.html#section-1",
    "title": "CSC 453",
    "section": "",
    "text": "What isn’t clear?\nComments? Thoughts?"
  },
  {
    "objectID": "day2.html#questions-to-consider-2",
    "href": "day2.html#questions-to-consider-2",
    "title": "CSC 453",
    "section": "Questions to consider",
    "text": "Questions to consider\n\nWhat is the chain of events that takes place before you are able to run a process?\nWhere do the different parts of the chain reside? How are they called?"
  },
  {
    "objectID": "day2.html#boot-is-like-a-relay-race",
    "href": "day2.html#boot-is-like-a-relay-race",
    "title": "CSC 453",
    "section": "Boot is like a relay race",
    "text": "Boot is like a relay race\n\nA sequence of programs\nEach stage:\n\nHas slightly more power\nLoads the next stage\nJumps to it"
  },
  {
    "objectID": "day2.html#power-on",
    "href": "day2.html#power-on",
    "title": "CSC 453",
    "section": "Power-On",
    "text": "Power-On\n\nCPU resets\nInstruction pointer set to a fixed address\nExecution begins in firmware (ROM)\nThe CPU does not know what an OS is"
  },
  {
    "objectID": "day2.html#firmware-bios-uefi",
    "href": "day2.html#firmware-bios-uefi",
    "title": "CSC 453",
    "section": "Firmware (BIOS / UEFI)",
    "text": "Firmware (BIOS / UEFI)\n\nInitializes RAM\nInitializes minimal hardware\nFinds one program to run (bootloader)\nLoads it into memory\nJumps to it"
  },
  {
    "objectID": "day2.html#bootloaders-job-grub-example",
    "href": "day2.html#bootloaders-job-grub-example",
    "title": "CSC 453",
    "section": "Bootloader’s job (GRUB Example)",
    "text": "Bootloader’s job (GRUB Example)\n\nUnderstand filesystems\nLoad the kernel image\nLoad the initramfs\nPass arguments to the kernel\nJump to the kernel entry point\nProvides kernel command line args\nroot=/dev/sda1\ninit=/sbin/init\nconsole=ttyS0"
  },
  {
    "objectID": "day2.html#what-the-bootloader-does-not-do",
    "href": "day2.html#what-the-bootloader-does-not-do",
    "title": "CSC 453",
    "section": "What the bootloader does not do",
    "text": "What the bootloader does not do\n\nDoes not schedule processes\nDoes not manage memory long-term\nDoes not run the OS"
  },
  {
    "objectID": "day2.html#kernel",
    "href": "day2.html#kernel",
    "title": "CSC 453",
    "section": "Kernel",
    "text": "Kernel\nThink of the kernel in phases\n\nSelf-setup\nHardware abstraction\nUserspace handoff"
  },
  {
    "objectID": "day2.html#kernel-self-setup",
    "href": "day2.html#kernel-self-setup",
    "title": "CSC 453",
    "section": "Kernel self-setup",
    "text": "Kernel self-setup\n\nSets up page tables\nEnables virtual memory\nInitializes scheduler\nSets up interrupts\n\n\nThe kernel cannot rely on anything yet: it is building the world."
  },
  {
    "objectID": "day2.html#kernel-hardware-abstractions",
    "href": "day2.html#kernel-hardware-abstractions",
    "title": "CSC 453",
    "section": "Kernel hardware abstractions",
    "text": "Kernel hardware abstractions\nThis is where hardware becomes an abstraction.\n\nDetects hardware\nLoads drivers\nTurns devices into files:\n\n/dev/sda\n/dev/tty\n\nCreates kernel threads"
  },
  {
    "objectID": "day2.html#userspace-handoff",
    "href": "day2.html#userspace-handoff",
    "title": "CSC 453",
    "section": "Userspace handoff",
    "text": "Userspace handoff\n\nMounts the root filesystem\nChooses one program to run\nExecutes it with execve()\nexecve(\"/sbin/init\", ...);"
  },
  {
    "objectID": "day2.html#init-pid-1",
    "href": "day2.html#init-pid-1",
    "title": "CSC 453",
    "section": "Init (PID 1)",
    "text": "Init (PID 1)\n\nFirst userspace process\nAlways PID 1\nParent of all other processes\n\n\nIf PID 1 exits?\n\nThe kernel panics or shuts down"
  },
  {
    "objectID": "day2.html#section-2",
    "href": "day2.html#section-2",
    "title": "CSC 453",
    "section": "",
    "text": "What isn’t clear?\nComments? Thoughts?"
  },
  {
    "objectID": "day2.html#questions-to-consider-3",
    "href": "day2.html#questions-to-consider-3",
    "title": "CSC 453",
    "section": "Questions to consider",
    "text": "Questions to consider\n\nWhat are the different kernel paradigms?\nWhy would you choose one over the other?"
  },
  {
    "objectID": "day2.html#paradigms",
    "href": "day2.html#paradigms",
    "title": "CSC 453",
    "section": "Paradigms",
    "text": "Paradigms\n\nThe OS offers a number of services. What should go in the kernel?\n\nIPC\nVFS\nFile system\nScheduler\nVirtual Memory\nDevice drivers"
  },
  {
    "objectID": "day2.html#monolithic-kernels",
    "href": "day2.html#monolithic-kernels",
    "title": "CSC 453",
    "section": "Monolithic kernels",
    "text": "Monolithic kernels\n\nOldest, very common design (Linux, Windows 9x, BSDs)\nSingle piece of code in memory\nLimited information hiding\n\nOne part of the kernel can directly access data and functions of other parts"
  },
  {
    "objectID": "day2.html#monolithic-kernels-contd",
    "href": "day2.html#monolithic-kernels-contd",
    "title": "CSC 453",
    "section": "Monolithic kernels (cont’d)",
    "text": "Monolithic kernels (cont’d)\n\nQ: What happens when you need something new supported (new hardware device, new system call, new filesystem)?\nModules (loadable kernel modules - LKMs) allow for flexibility, customization, support\n\nPros?\n\nMemory savings\nFlexibility\nMinimal downtime\n\nCons?\n\n(minor) fragmentation: the base kernel can be loaded contiguously in memory\nSecurity (https://github.com/m0nad/Diamorphine DO NOT USE THIS, IT’S SIMPLY TO SHOW YOU)"
  },
  {
    "objectID": "day2.html#layered-kernels",
    "href": "day2.html#layered-kernels",
    "title": "CSC 453",
    "section": "Layered kernels",
    "text": "Layered kernels\n\nDijkstra created the THE OS in the 60s, introducing the concept Each inner layer is more privileged; required a trap to move down layers\nHardware-enforcement possible\nIntel announced in May 2024 that the new architectures will only have rings 0 and 3"
  },
  {
    "objectID": "day2.html#microkernels",
    "href": "day2.html#microkernels",
    "title": "CSC 453",
    "section": "Microkernels",
    "text": "Microkernels\n\n\n\nPopular research area long ago, didn’t win (although people remain interested in the principles)\nAll non-essential components removed from the kernel, for modularization, extensibility, isolation, security, and ease of management\nA collection of OS services running in user space\nDownsides?\n\nHeavy communication costs through message passing (marshaled through the kernel)"
  },
  {
    "objectID": "day2.html#monolithic-vs-microkernel",
    "href": "day2.html#monolithic-vs-microkernel",
    "title": "CSC 453",
    "section": "Monolithic vs Microkernel",
    "text": "Monolithic vs Microkernel"
  },
  {
    "objectID": "day2.html#section-3",
    "href": "day2.html#section-3",
    "title": "CSC 453",
    "section": "",
    "text": "What isn’t clear?\nComments? Thoughts?"
  },
  {
    "objectID": "day1.html#who-am-i",
    "href": "day1.html#who-am-i",
    "title": "CSC 453",
    "section": "Who am I?",
    "text": "Who am I?\n\nhttps://pschmitt.net\nAcademics\n\nPhD at UCSB\nResearcher (summers) at ICSI\nPostdoc then research faculty at Princeton\nSome other stops… USC, Stanford, UH\n\nPrivacy startup co-founder & CEO, measurement startup COO\nMain focuses\n\nIntegrating privacy and security into systems that we all use\nML for network management\nConnectivity / privacy in challenging environments"
  },
  {
    "objectID": "day1.html#this-class-1",
    "href": "day1.html#this-class-1",
    "title": "CSC 453",
    "section": "This class",
    "text": "This class\n\nToo much to cover in one term: survey of important topics\nCourse Canvas: https://canvas.calpoly.edu/courses/168889\nSyllabus: https://schmittpaul.github.io/CSC453W26/syllabus.pdf\nWaitlists…\nWhat OSes do you all run?"
  },
  {
    "objectID": "day1.html#who-are-you",
    "href": "day1.html#who-are-you",
    "title": "CSC 453",
    "section": "Who are you?",
    "text": "Who are you?\n\nName / Major / Year\nWhere do you identify as your hometown?"
  },
  {
    "objectID": "day1.html#how-to-succeed-in-this-class",
    "href": "day1.html#how-to-succeed-in-this-class",
    "title": "CSC 453",
    "section": "How to succeed in this class",
    "text": "How to succeed in this class\n\nTurn things in on time\nAttend class\n\n… on time. Lectures will start at 10 after the hour\n\n\nAsk questions\n\nI’m very flexible about how much we cover this semester\nI would rather teach less and have everyone understand it\nOur back-and-forth during class is the one of the few indicators I have of how much you are absorbing\n\nTalk to me if you are struggling"
  },
  {
    "objectID": "day1.html#what-are-we-doing-here",
    "href": "day1.html#what-are-we-doing-here",
    "title": "CSC 453",
    "section": "What are we doing here?",
    "text": "What are we doing here?\n\n\n\nHow many of you have participated in OS development?\nHow many of you regularly program in languages that use operating system abstractions directly?\nAnd C is a decreasingly popular language!\nSo why study operating systems? Why is this class even offered? Why is it required?"
  },
  {
    "objectID": "day1.html#why-take-this-class",
    "href": "day1.html#why-take-this-class",
    "title": "CSC 453",
    "section": "Why take this class",
    "text": "Why take this class\n\nYou are required to do so in order to graduate\nReality: this is how computers really work, and as a computer scientist or engineer you should know how computers really work\nUbiquity: operating systems are everywhere and you are likely to eventually encounter them or their limitations\nBeauty: operating systems are examples of mature solutions to difficult design and engineering problems. Studying them will improve your ability to design and implement abstractions"
  },
  {
    "objectID": "day1.html#course-progression",
    "href": "day1.html#course-progression",
    "title": "CSC 453",
    "section": "Course progression",
    "text": "Course progression\n\nIntroduction to operating system abstractions and structures\nAbstracting and multiplexing:\n\nCPU: interrupts, context, threads, processes, processor scheduling, thread synchronization, deadlocks\nMemory: memory layout, address translation, paging and segmentation, address spaces, translation caching, page fault handling, page eviction, swapping\nFile systems and storage: disk scheduling, on-disk layout, files, buffer cache, crash and recovery\nSecurity (time permitting)"
  },
  {
    "objectID": "day1.html#questions-to-consider",
    "href": "day1.html#questions-to-consider",
    "title": "CSC 453",
    "section": "Questions to consider",
    "text": "Questions to consider\n\nWhat is an operating system?\nWhat do they do?\nHow did OSes evolve?\nHow do the requirements differ for different OSes?"
  },
  {
    "objectID": "day1.html#what-is-an-operating-system",
    "href": "day1.html#what-is-an-operating-system",
    "title": "CSC 453",
    "section": "What is an operating system?",
    "text": "What is an operating system?\n\n\n\nOperating System:\n\nA computer program that\nmultiplexes hardware resources and\nimplements useful abstractions.\n\nThe OS is just another computer program. Has the highest privilege. The core of the OS consists of the kernel\nMultiplexing allows multiple people or programs to use the same set of hardware resources - processors, memory, disks, network connection - safely and efficiently.\nAbstractions simplify the usage of hardware resources by organizing information or implementing new capabilities."
  },
  {
    "objectID": "day1.html#os-history---how-did-we-get-here",
    "href": "day1.html#os-history---how-did-we-get-here",
    "title": "CSC 453",
    "section": "OS history - how did we get here?",
    "text": "OS history - how did we get here?\n\n\n\nStarted out as libraries to provide common functionality across programs\n\nSee any issues with this approach?\n\nLater, evolved from procedure call to system call\n\nWhat’s the difference?\n\nEvolved from running a single program to multiple processes concurrently\n\nNew issues to solve?\n\n\n\n\n\n\n\n\n\nImagine you allowed any process to read anywhere from the disk or memory. There is no privacy.\nMemory protection, concurrency / scheduling issues"
  },
  {
    "objectID": "day1.html#types-of-operating-systems",
    "href": "day1.html#types-of-operating-systems",
    "title": "CSC 453",
    "section": "Types of operating systems",
    "text": "Types of operating systems\n\nDesktop\nTime share/Mainframe\nMobile\nWeb\nReal-time\nEmbedded\nVirtual Machines"
  },
  {
    "objectID": "day1.html#tldr",
    "href": "day1.html#tldr",
    "title": "CSC 453",
    "section": "Tl;dr",
    "text": "Tl;dr\nOSes continue to evolve as environments (i.e., constraints) change"
  },
  {
    "objectID": "day1.html#section-1",
    "href": "day1.html#section-1",
    "title": "CSC 453",
    "section": "",
    "text": "What isn’t clear?\nComments? Thoughts?"
  },
  {
    "objectID": "day1.html#questions-to-consider-1",
    "href": "day1.html#questions-to-consider-1",
    "title": "CSC 453",
    "section": "Questions to consider",
    "text": "Questions to consider\n\nWhat are the main abstractions OSes provide?\nWhat are the abstraction challenges?"
  },
  {
    "objectID": "day1.html#abstractions",
    "href": "day1.html#abstractions",
    "title": "CSC 453",
    "section": "Abstractions",
    "text": "Abstractions\n\nAbstractions simplify application design by:\n\nhiding undesirable properties,\nadding new capabilities, and\norganizing information\n\nAbstractions provide an interface to application programmers that separates policy—what the interface commits to accomplishing—from mechanism—how the interface is implemented."
  },
  {
    "objectID": "day1.html#what-are-the-abstractions",
    "href": "day1.html#what-are-the-abstractions",
    "title": "CSC 453",
    "section": "What are the abstractions?",
    "text": "What are the abstractions?\n\nCPUs\n\nProcesses, threads\n\nMemory\n\nAddress space\n\nDisk\n\nFiles"
  },
  {
    "objectID": "day1.html#example-os-abstraction-file-systems",
    "href": "day1.html#example-os-abstraction-file-systems",
    "title": "CSC 453",
    "section": "Example OS abstraction: file systems",
    "text": "Example OS abstraction: file systems\n\nWhat undesirable properties do file systems hide?\n\nDisks are slow!\nChunks of storage are actually distributed all over the disk\nDisk storage may fail!\n\nWhat new capabilities do files add?\n\nGrowth and shrinking\nOrganization into directories, searchability\n\nWhat information do files help organize?\n\nOwnership and permissions\nAccess time, modification time, type, etc."
  },
  {
    "objectID": "day1.html#abstraction-tradeoffs---discussion",
    "href": "day1.html#abstraction-tradeoffs---discussion",
    "title": "CSC 453",
    "section": "Abstraction tradeoffs - discussion",
    "text": "Abstraction tradeoffs - discussion\n\nIdentify undesirable properties hidden by, new capabilities added, and info organization provided with these abstractions:\n\nProcess / threads\nAddress space\n\n\n\nProcesses/Threads\n\nHiding undesirable properties:\n\nExample: The process abstraction hides the complexity of CPU scheduling and context switching. Applications don’t need to manage the low-level details of how the CPU switches between different tasks. Similarly, the thread abstraction hides the intricacies of managing multiple execution paths within a single process, allowing developers to focus on the logic of concurrent tasks.\n\nAdding new capabilities:\n\nExample: Processes provide isolation between different applications, ensuring that one misbehaving application doesn’t affect others. Threads within a process allow for parallel execution of tasks, improving performance and responsiveness. Additionally, operating systems often provide inter-process communication (IPC) mechanisms, enabling processes to coordinate and share data.\n\nOrganizing information:\n\nExample: The process abstraction organizes the execution environment by encapsulating the code, data, and resources needed for a program to run. Threads further organize execution by dividing tasks within a process into smaller, manageable units. This organization helps in structuring complex applications and improving their maintainability.\n\n\nMemory Address Space\n\nHiding undesirable properties:\n\nExample: The memory address space abstraction hides the physical memory layout from applications. Programs use virtual addresses, which the operating system maps to physical memory locations. This abstraction also hides the details of memory fragmentation and allocation, simplifying memory management for developers.\n\nAdding new capabilities:\n\nExample: Virtual memory allows applications to use more memory than physically available by swapping data to and from disk. This capability enables larger and more complex applications to run on systems with limited physical memory. Additionally, memory protection mechanisms prevent one process from accessing the memory of another, enhancing system stability and security.\n\nOrganizing information:\n\nExample: The memory address space abstraction organizes memory into segments such as code, data, heap, and stack. This organization helps in managing different types of data efficiently and ensures that memory is used in a structured manner. For instance, the stack is used for function calls and local variables, while the heap is used for dynamic memory allocation."
  },
  {
    "objectID": "day1.html#abstraction-pros-cons",
    "href": "day1.html#abstraction-pros-cons",
    "title": "CSC 453",
    "section": "Abstraction pros / cons",
    "text": "Abstraction pros / cons\n\nAdvantages of OS providing abstractions?\n\nAllow applications to reuse common facilities\nMake different devices look the same\nProvide higher-level or more useful functionality\n\nChallenges?\n\nWhat are the correct abstractions?\nHow much should be exposed?"
  },
  {
    "objectID": "day1.html#os-design-requirements---what-do-we-need",
    "href": "day1.html#os-design-requirements---what-do-we-need",
    "title": "CSC 453",
    "section": "OS design requirements - what do we need?",
    "text": "OS design requirements - what do we need?\n\nConvenience, abstraction of hardware resources for user programs\nEfficiency of usage of CPU, memory, etc.\nIsolation between multiple processes\nReliability, the OS must not fail\nOther:\n\nSecurity\nMobility"
  },
  {
    "objectID": "day1.html#section-2",
    "href": "day1.html#section-2",
    "title": "CSC 453",
    "section": "",
    "text": "What isn’t clear?\nComments? Thoughts?"
  }
]